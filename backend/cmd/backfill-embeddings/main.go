package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/yourusername/justsell/backend/internal/config"
	"github.com/yourusername/justsell/backend/internal/repository"
	"github.com/yourusername/justsell/backend/internal/service"

	"github.com/joho/godotenv"
)

func main() {
	log.Println("üîÑ Embeddings Backfill Script")
	log.Println("This script will generate embeddings for all listings that don't have them yet.")
	log.Println("üìò Runbook: schedule this command periodically in production to heal listings that remain without embeddings after async retry exhaustion.")

	// Load .env file from backend directory
	if err := godotenv.Load(); err != nil {
		log.Println("‚ÑπÔ∏è  No .env file found (using environment variables)")
	}

	// Load configuration
	cfg := config.Load()

	if cfg.GeminiKey == "" {
		log.Fatal("‚ùå GEMINI_API_KEY environment variable is required")
	}

	// Connect to database
	ctx := context.Background()
	db, err := pgxpool.New(ctx, cfg.DatabaseURL)
	if err != nil {
		log.Fatal("‚ùå Failed to connect to database:", err)
	}
	defer db.Close()
	log.Println("‚úÖ Database connected")

	// Create services
	vectorRepo := repository.NewVectorRepository(db)
	embeddingsService := service.NewEmbeddingsService(cfg.GeminiKey, cfg.GeminiEmbeddingModel)
	log.Println("‚úÖ Services initialized")
	targetEmbeddingModel := embeddingsService.PreferredModel()
	log.Printf("üéØ Target embedding model: %s", targetEmbeddingModel)
	forceAll := strings.TrimSpace(os.Getenv("BACKFILL_FORCE_ALL")) == "1"
	if forceAll {
		log.Println("‚ö†Ô∏è  BACKFILL_FORCE_ALL=1 enabled: re-embedding all active listings")
	}

	// Get active listings missing embeddings or generated by a different model.
	query := `
		SELECT
			id,
			title,
			description,
			COALESCE(category, '') AS category,
			COALESCE(category_fields, '{}'::jsonb) AS category_fields
		FROM listings
		WHERE status = 'active'
		  AND (
			$1::bool
			OR embedding IS NULL
			OR COALESCE(embedding_model, '') <> $2
		  )
		ORDER BY id ASC
	`

	rows, err := db.Query(ctx, query, forceAll, targetEmbeddingModel)
	if err != nil {
		log.Fatal("‚ùå Failed to query listings:", err)
	}
	defer rows.Close()

	// Collect listings
	type listingData struct {
		ID          int
		Title       string
		Description string
		Category    string
		Fields      map[string]interface{}
	}

	var listings []listingData
	for rows.Next() {
		var l listingData
		var desc, category *string
		var categoryFieldsRaw []byte
		if err := rows.Scan(&l.ID, &l.Title, &desc, &category, &categoryFieldsRaw); err != nil {
			log.Printf("‚ö†Ô∏è  Failed to scan listing: %v", err)
			continue
		}
		if desc != nil {
			l.Description = *desc
		}
		if category != nil {
			l.Category = *category
		}
		l.Fields = map[string]interface{}{}
		if len(categoryFieldsRaw) > 0 {
			if err := json.Unmarshal(categoryFieldsRaw, &l.Fields); err != nil {
				log.Printf("‚ö†Ô∏è  Failed to parse category_fields for listing %d: %v", l.ID, err)
				l.Fields = map[string]interface{}{}
			}
		}
		listings = append(listings, l)
	}

	if len(listings) == 0 {
		log.Println("‚úÖ No listings need embedding generation!")
		return
	}

	log.Printf("üìä Found %d listings without embeddings\n", len(listings))

	// Process each listing
	successCount := 0
	errorCount := 0

	for i, l := range listings {
		log.Printf("[%d/%d] Processing listing %d: %s", i+1, len(listings), l.ID, l.Title)

		embedding, embeddingModel, err := embeddingsService.GenerateListingEmbeddingFromFieldsWithModel(ctx, l.Title, l.Description, l.Category, l.Fields)
		if err != nil {
			log.Printf("  ‚ùå Failed to generate embedding: %v", err)
			errorCount++
			continue
		}

		if err := vectorRepo.UpdateEmbedding(ctx, l.ID, embedding, embeddingModel); err != nil {
			log.Printf("  ‚ùå Failed to store embedding: %v", err)
			errorCount++
			continue
		}

		log.Printf("  ‚úÖ Embedding stored")
		successCount++

		// Rate limiting - don't overwhelm Gemini API
		time.Sleep(200 * time.Millisecond)
	}

	log.Println("")
	log.Println("========== Summary ==========")
	log.Printf("‚úÖ Successful: %d", successCount)
	log.Printf("‚ùå Failed: %d", errorCount)
	log.Printf("üìä Total: %d", len(listings))
	log.Println("==============================")

	if errorCount > 0 {
		os.Exit(1)
	}
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func init() {
	// Suppress unused import error
	_ = fmt.Sprint
}
