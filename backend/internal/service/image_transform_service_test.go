package service

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestParseImageTransformResponseInlineData(t *testing.T) {
	payload := map[string]any{
		"candidates": []any{
			map[string]any{
				"content": map[string]any{
					"parts": []any{
						map[string]any{
							"inline_data": map[string]any{
								"mime_type": "image/png",
								"data":      base64.StdEncoding.EncodeToString([]byte("pngdata")),
							},
						},
					},
				},
			},
		},
	}
	body, _ := json.Marshal(payload)

	img, mimeType, err := parseImageTransformResponse(body)
	if err != nil {
		t.Fatalf("expected success, got error: %v", err)
	}
	if string(img) != "pngdata" {
		t.Fatalf("expected decoded image bytes, got %q", string(img))
	}
	if mimeType != "image/png" {
		t.Fatalf("expected image/png, got %q", mimeType)
	}
}

func TestParseImageTransformResponseMissingImage(t *testing.T) {
	payload := map[string]any{
		"candidates": []any{
			map[string]any{
				"content": map[string]any{
					"parts": []any{map[string]any{"text": "no image"}},
				},
			},
		},
	}
	body, _ := json.Marshal(payload)

	_, _, err := parseImageTransformResponse(body)
	if err == nil {
		t.Fatal("expected error when no image output is present")
	}
}

func TestGenerateProBackdropBuildsRequestAndParsesImage(t *testing.T) {
	var capturedBody string

	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer r.Body.Close()
		raw, _ := io.ReadAll(r.Body)
		capturedBody = string(raw)

		resp := map[string]any{
			"candidates": []any{
				map[string]any{
					"content": map[string]any{
						"parts": []any{
							map[string]any{
								"inline_data": map[string]any{
									"mime_type": "image/jpeg",
									"data":      base64.StdEncoding.EncodeToString([]byte("generated")),
								},
							},
						},
					},
				},
			},
		}
		_ = json.NewEncoder(w).Encode(resp)
	}))
	defer server.Close()

	svc := NewImageTransformService("test-key", "test-model")
	svc.modelURL = server.URL
	svc.httpClient = server.Client()

	inputBytes := []byte{0x20, 0xFF, 0xD8, 0xFF, 0x00, 0x20}
	expectedInputBase64 := base64.StdEncoding.EncodeToString(inputBytes)

	result, err := svc.GenerateProBackdrop(context.Background(), ImageTransformInput{
		ImageData: inputBytes,
		MimeType:  "image/jpeg",
		Style:     ProBackdropDefaultStyle,
	})
	if err != nil {
		t.Fatalf("GenerateProBackdrop returned error: %v", err)
	}

	if string(result.ImageData) != "generated" {
		t.Fatalf("expected generated bytes, got %q", string(result.ImageData))
	}
	if result.MimeType != "image/jpeg" {
		t.Fatalf("expected image/jpeg, got %q", result.MimeType)
	}
	if result.PromptVersion != ProBackdropPromptVersion {
		t.Fatalf("expected prompt version %q, got %q", ProBackdropPromptVersion, result.PromptVersion)
	}

	if !strings.Contains(capturedBody, "replace_background_only") {
		t.Fatalf("expected strict system prompt in request body")
	}
	if !strings.Contains(capturedBody, "inline_data") {
		t.Fatalf("expected inline_data image payload in request body")
	}
	if !strings.Contains(capturedBody, expectedInputBase64) {
		t.Fatalf("expected request body to contain exact (untrimmed) input image base64 payload")
	}
}
